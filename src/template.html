<!DOCTYPE html>
<html style="height:100%;width:100%;margin:0;padding:0">
    <head>
        <style>
        <!-- leafletcss -->
        .leaflet-tile {
            opacity: 1 !important;
        }
        .leaflet-fade-anim, .leaflet-zoom-anim {
            transition: none;
        }
        body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
        }
        #map {
            background: lightblue;
            height: 100%;
            width: 100%;
        }
        </style>
        <script>
        <!-- leafletjs -->
        <!-- Handlebars conditions for arrows -->
        {{#if arrows}}
        //leafletpolylinedecorator//
        {{/if}}
        </script>

        {{#if vectorserverUrl}}
            <style>
            <!-- mapboxcss -->
            </style>
            <script>
            <!-- mapboxjs -->
            <!-- leafletmapboxjs -->
            </script>
        {{/if}}

    </head>
    <body>
        <div id="map"></div>
        <script>

            {{#if arrows}}
                var decorator = L.Symbol.arrowHead({
                    pixelSize: 6,
                    polygon: false,
                    pathOptions: {
                        color: '#FFF',
                        opacity: 1,
                        weight: 2,
                    }
                })
            {{/if}}

            var maxZoom = Number({{maxZoom}});
            var initialPoint = L.latLng(-34.921779, -57.9524339);

            var map = new L.Map('map', {
                zoomControl: false,
                center: initialPoint,
                zoom: maxZoom,
                maxZoom: maxZoom
            });
            map.attributionControl.setPrefix('').addAttribution('{{ attribution }}');

            {{#if scale}}
                L.control.scale({{{scale}}}).addTo(map);
            {{/if}}

            {{#if geojson }}
                console.log('GeoJSON parameter injected into template:', {{{ geojson }}});
                console.log('GeoJSON parameter before L.geoJson call:', {{{ geojson }}});
                {{#if markerIconOptions}}
                    var myIcon = L.icon({{{markerIconOptions}}});
                {{else}}
                    var myIcon = L.icon({
                        iconUrl: "data:image/png;base64,//markericonpng//",
                        iconSize: [25, 41],
                        iconAnchor: [15, 41]
                    });
                {{/if}}
                var geojsonlayer = L.geoJson({{{ geojson }}}, {
                    pointToLayer: function (feature, latlng) {
                        if (feature.markerIconOptions) {
                            return L.marker(latlng, {icon: L.icon(feature.markerIconOptions)})
                        }
                        return L.marker(latlng, {icon: myIcon});
                    },
                    onEachFeature: function (feature, layer) {
                        {{#if arrows}}
                            if (feature.type == 'LineString' || (feature.geometry && feature.geometry.type == 'LineString')) {
                                L.polylineDecorator(L.polyline(layer._latlngs), {patterns: [
                                    {offset: 5, repeat: 150, symbol: decorator},
                                    {offset: 12, repeat: 150, symbol: decorator},
                                    {offset: 19, repeat: 150, symbol: decorator},
                                ]}).addTo(map);
                            }
                        {{/if}}
                    },
                    style: function(feature) {
                        var style = {}
                        {{#if arrows}}
                            Object.assign(style, { weight: 10 })
                        {{/if}}
                        {{#if style}}
                            Object.assign(style, {{{ style }}})
                        {{/if}}
                        if (feature.geometry.pathOptions) {
                            Object.assign(style, feature.geometry.pathOptions)
                        }
                        return style
                    },
                });
                geojsonlayer.addTo(map);
                map.fitBounds(geojsonlayer.getBounds(), {maxZoom: maxZoom});
            {{/if}}

            {{#if center}}
                map.panTo(L.latLng('{{ center }}'.split(',')[1], '{{ center }}'.split(',')[0]), {animate: false});
            {{else}}
                {{#if geojson}}
                {{else}}
                    map.panTo(initialPoint, {animate: false});
                {{/if}}
            {{/if}}

            {{#if zoom}}
                map.setZoom({{ zoom }}, {animate: false});
            {{else}}
                {{#if geojson }}
                {{else}}
                    map.setZoom(maxZoom, {animate: false})
                {{/if}}
            {{/if}}

            {{#if vectorserverUrl}}
                console.log('Initializing map with vector server URL');
                var backgroundLayer = L.mapboxGL({
                    accessToken: '{{ vectorserverToken }}',
                    style: '{{{ vectorserverUrl }}}'
                });
            {{else}}
                console.log('Initializing map with tile server URL');
                {{#if tileserverUrl}}
                    console.log('Creating tileLayer with URL:', '{{{tileserverUrl}}}');
                    var backgroundLayer = L.tileLayer(
                        '{{{tileserverUrl}}}',
                        {
                            maxZoom: maxZoom,
                            fadeAnimation: false
                        }
                    );
                {{/if}}
            {{/if}}
            console.log('Adding backgroundLayer to map');
            backgroundLayer.addTo(map).on('load', function() {
                console.log('backgroundLayer load event fired');
                window.mapRendered = true;
                console.log('window.mapRendered set to:', window.mapRendered);
                // Additional logging to check if tiles are loaded
                console.log('Tiles loaded:', map._tilesToLoad || 'No tiles to load info');
                // Confirming that the load event listener is executed
                console.log('Load event listener executed successfully.');
                // Log the state of the map and backgroundLayer after load event
                console.log('State of map after backgroundLayer load event:', {
                    hasLayer: map.hasLayer(backgroundLayer),
                    isLoading: map.isLoading(),
                    tilesToLoad: map._tilesToLoad,
                    tileLayers: map._tileLayers
                });
                // Log the bounds of the map to confirm it is set correctly
                console.log('Map bounds after load event:', map.getBounds().toBBoxString());
                // Additional check to confirm the map is rendered
                if (map._tilesToLoad === 0 && map.hasLayer(backgroundLayer)) {
                    console.log('Map rendering confirmed, tiles loaded and background layer present.');
                } else {
                    console.error('Map rendering issue detected, tiles or background layer not loaded correctly.');
                    window.mapRendered = false; // Set to false if the map has not rendered correctly
                }
            }).on('error', function(e) {
                console.error('backgroundLayer error event fired', e);
                // Log the error to understand why the background layer failed to load
                console.error('Background layer failed to load with error:', e.message || e);
                // Additional logging to capture error details
                console.log('Error details:', e.message || e);
                // Set window.mapRendered to false to indicate the map has not rendered correctly
                window.mapRendered = false;
                console.log('window.mapRendered set to:', window.mapRendered);
            });
            console.log('backgroundLayer load and error event listeners added');
        </script>
    </body>
</html>
